<?php
/**
 * Plugin Name: Ingredient Importer
 * Description: Importer CSV/XLSX -> Custom Post Type `ingredient_fiche`. Includes admin UI, WP-CLI, CRON worker and logs. No third-party WP plugin required. Supports PhpSpreadsheet if available, otherwise falls back to CSV.
 * Version: 1.0.0
 * Author: Generated by ChatGPT (developer senior brief)
 */

if ( ! defined( 'ABSPATH' ) ) {
    exit;
}

if ( file_exists(__DIR__ . '/vendor/autoload.php') ) {
    require_once __DIR__ . '/vendor/autoload.php';
} else {
    error_log("AUTLOAD NOT FOUND: " . __DIR__ . '/vendor/autoload.php');
}

class Ingredient_Importer {
    public static $instance;
    public $version = '1.0.0';
    public $upload_subdir = 'ingredient-imports';
    public $option_key = 'ingredient_importer_options';
    public $log_table;

    public static function instance() {
        if ( ! self::$instance ) {
            self::$instance = new self();
        }
        return self::$instance;
    }

    public function __construct() {
        global $wpdb;
        $this->log_table = $wpdb->prefix . 'ingredient_import_logs';

        add_action( 'init', [ $this, 'register_cpt' ] );
        register_activation_hook( __FILE__, [ $this, 'activate' ] );
        add_action( 'admin_menu', [ $this, 'admin_menu' ] );
        add_action( 'admin_post_ingredient_import', [ $this, 'handle_upload_post' ] );
        add_action( 'admin_enqueue_scripts', [ $this, 'enqueue_assets' ] );

        // Cron hook
        add_action( 'ingredient_importer_cron_event', [ $this, 'cron_process_pending_imports' ] );

        // Register REST endpoints (optional)
        add_action( 'rest_api_init', [ $this, 'register_rest_routes' ] );
    }

    public function activate() {
        $this->create_tables();
        // schedule hourly if not scheduled
        if ( ! wp_next_scheduled( 'ingredient_importer_cron_event' ) ) {
            wp_schedule_event( time(), 'hourly', 'ingredient_importer_cron_event' );
        }
    }

    public function maybe_activate() {
        if ( get_option('ingredient_importer_installed') ) return;
        $this->register_cpt();
        $this->activate(); // crée la table
        update_option('ingredient_importer_installed', 1);
    }

    public function create_tables() {
        global $wpdb;
        $charset_collate = $wpdb->get_charset_collate();

        $sql1 = "CREATE TABLE {$this->log_table} (
            id BIGINT UNSIGNED NOT NULL AUTO_INCREMENT,
            file_name VARCHAR(255) NOT NULL,
            file_path VARCHAR(255) NOT NULL,
            rows_total INT DEFAULT 0,
            rows_processed INT DEFAULT 0,
            inserted INT DEFAULT 0,
            updated INT DEFAULT 0,
            ignored INT DEFAULT 0,
            errors TEXT,
            status ENUM('pending','running','done','failed') DEFAULT 'pending',
            started_at DATETIME NULL,
            finished_at DATETIME NULL,
            user_id BIGINT NULL,
            PRIMARY KEY (id)
        ) $charset_collate";

        require_once( ABSPATH . 'wp-admin/includes/upgrade.php' );
        dbDelta( $sql1 );
    }

    public function register_cpt() {
        if ( post_type_exists( 'ingredient_fiche' ) ) {
            return;
        }

        $labels = [
            'name' => 'Fiches Ingrédients',
            'singular_name' => 'Fiche Ingrédient',
            'menu_name' => 'Fiches Ingrédients',
            'name_admin_bar' => 'Fiche Ingrédient',
        ];

        $args = [
            'labels' => $labels,
            'public' => false,
            'show_ui' => true,
            'show_in_menu' => false, // custom menu
            'supports' => [ 'title', 'editor' ],
            'capability_type' => 'post',
            'has_archive' => false,
            'menu_position' => 58,
        ];

        register_post_type( 'ingredient_fiche', $args );
    }

    public function admin_menu() {
        add_menu_page( 'Fiches Ingrédients', 'Fiches Ingrédients', 'manage_options', 'ingredient_fiches_main', [ $this, 'admin_list_page' ], 'dashicons-clipboard', 58 );
        add_submenu_page( 'ingredient_fiches_main', 'Importer', 'Importer', 'manage_options', 'ingredient_fiches_import', [ $this, 'admin_import_page' ] );
        add_submenu_page( 'ingredient_fiches_main', 'Historique Import', 'Historique Import', 'manage_options', 'ingredient_fiches_history', [ $this, 'admin_history_page' ] );
    }

    public function enqueue_assets( $hook ) {
        // enqueue CSS/JS only for our pages
        if ( strpos( $hook, 'ingredient_fiches' ) !== false ) {
            wp_enqueue_style( 'ingredient-importer-admin', plugins_url( '', __FILE__ ) . '/assets/admin.css' );
            wp_enqueue_script( 'ingredient-importer-admin', plugins_url( '', __FILE__ ) . '/assets/admin.js', [ 'jquery' ], $this->version, true );
            wp_localize_script( 'ingredient-importer-admin', 'IngredientImporter', [
                'ajax_url' => admin_url( 'admin-ajax.php' ),
                'nonce' => wp_create_nonce( 'ingredient_import_ajax' ),
            ] );
        }
    }

    public function admin_list_page() {
        // link to CPT native list
        echo '<div class="wrap"><h1>Fiches Ingrédients</h1>'; 
        echo '<p><a href="edit.php?post_type=ingredient_fiche" class="page-title-action">Voir toutes les fiches</a></p>'; 
        echo '<p><a href="admin.php?page=ingredient_fiches_import" class="button button-primary">Importer un fichier</a></p>'; 
        echo '</div>';
    }

    public function admin_import_page() {
        if ( ! current_user_can( 'manage_options' ) ) {
            wp_die( 'Accès refusé' );
        }

        $upload_dir = wp_upload_dir();
        $base = trailingslashit( $upload_dir['basedir'] ) . $this->upload_subdir;
        if ( ! file_exists( $base ) ) {
            wp_mkdir_p( $base );
        }

        ?>
        <div class="wrap">
            <h1>Importer des fiches ingrédients</h1>
            <form action="<?php echo esc_url( admin_url('admin-post.php') ); ?>" method="post" enctype="multipart/form-data">
                <?php wp_nonce_field( 'ingredient_import_action', 'ingredient_import_nonce' ); ?>
                <input type="hidden" name="action" value="ingredient_import">
                <table class="form-table">
                    <tr>
                        <th scope="row"><label for="ingredient_file">Fichier (.xlsx, .xls, .csv)</label></th>
                        <td><input type="file" name="ingredient_file" id="ingredient_file" required></td>
                    </tr>
                    <tr>
                        <th scope="row">Mode</th>
                        <td>
                            <label><input type="radio" name="import_mode" value="simulate" checked> Simuler (preview)</label><br>
                            <label><input type="radio" name="import_mode" value="execute"> Exécuter</label>
                        </td>
                    </tr>
                    <tr>
                        <th scope="row">Batch size</th>
                        <td><input type="number" name="batch_size" value="500" min="10" max="5000"></td>
                    </tr>
                </table>
                <?php submit_button( 'Lancer l\'import' ); ?>
            </form>
        </div>
        <?php
    }

    public function admin_history_page() {
        global $wpdb;

        $rows = $wpdb->get_results( "SELECT * FROM {$this->log_table} ORDER BY id DESC LIMIT 100" );
        echo '<div class="wrap"><h1>Historique des imports</h1><table class="wp-list-table widefat fixed striped"><thead><tr><th>ID</th><th>Fichier</th><th>Status</th><th>Rows</th><th>Inserted</th><th>Updated</th><th>Errors</th><th>Date</th></tr></thead><tbody>';
        foreach ( $rows as $r ) {
            echo '<tr>';
            echo '<td>' . esc_html( $r->id ) . '</td>';
            echo '<td>' . esc_html( $r->file_name ) . '</td>';
            echo '<td>' . esc_html( $r->status ) . '</td>';
            echo '<td>' . esc_html( $r->rows_processed ) . '</td>';
            echo '<td>' . esc_html( $r->inserted ) . '</td>';
            echo '<td>' . esc_html( $r->updated ) . '</td>';
            echo '<td>' . esc_html( substr( $r->errors, 0, 200 ) ) . '</td>';
            echo '<td>' . esc_html( $r->finished_at ) . '</td>';
            echo '</tr>';
        }
        echo '</tbody></table></div>';
    }

    public function handle_upload_post() {
        if ( ! current_user_can( 'manage_options' ) ) {
            wp_die( 'Unauthorized' );
        }
        check_admin_referer( 'ingredient_import_action', 'ingredient_import_nonce' );

        if ( empty( $_FILES['ingredient_file'] ) || $_FILES['ingredient_file']['error'] !== UPLOAD_ERR_OK ) {
            wp_redirect( add_query_arg( 'msg', 'no_file', admin_url( 'admin.php?page=ingredient_fiches_import' ) ) );
            exit;
        }

        $file = $_FILES['ingredient_file'];
        $allowed = [ 'xlsx', 'xls', 'csv' ];
        $file_ext = strtolower( pathinfo( $file['name'], PATHINFO_EXTENSION ) );
        if ( ! in_array( $file_ext, $allowed, true ) ) {
            wp_die( 'Format non supporté' );
        }

        $upload_dir = wp_upload_dir();
        $base = trailingslashit( $upload_dir['basedir'] ) . $this->upload_subdir;
        if ( ! file_exists( $base ) ) wp_mkdir_p( $base );

        $unique = time() . '-' . wp_unique_filename( $base, sanitize_file_name( $file['name'] ) );
        $destination = $base . '/' . $unique;
        if ( ! move_uploaded_file( $file['tmp_name'], $destination ) ) {
            wp_die( 'Impossible de déplacer le fichier' );
        }

        global $wpdb;
        $now = current_time( 'mysql' );
        $wpdb->insert( $this->log_table, [
            'file_name' => $file['name'],
            'file_path' => $destination,
            'rows_total' => 0,
            'rows_processed' => 0,
            'inserted' => 0,
            'updated' => 0,
            'ignored' => 0,
            'errors' => '',
            'status' => 'pending',
            'started_at' => null,
            'finished_at' => null,
            'user_id' => get_current_user_id(),
        ], [ '%s','%s','%d','%d','%d','%d','%d','%s','%s','%s','%d' ] );

        $log_id = $wpdb->insert_id;

        // If simulate, do a quick preview synchronously
        $mode = sanitize_text_field( $_POST['import_mode'] ?? 'simulate' );
        $batch_size = intval( $_POST['batch_size'] ?? 500 );

        if ( $mode === 'simulate' ) {
            $preview = $this->preview_file( $destination );
            // Show preview (simple)
            echo '<div class="wrap"><h1>Preview import</h1>';
            echo '<p>Fichier: ' . esc_html( $file['name'] ) . '</p>';
            echo '<pre style="white-space:pre-wrap;border:1px solid #ddd;padding:12px;">';
            echo esc_html( print_r( $preview, true ) );
            echo '</pre>';
            echo '<p><a href="' . esc_url( admin_url( 'admin.php?page=ingredient_fiches_import' ) ) . '">Retour</a></p>';
            echo '</div>';
            exit;
        }

        // For real execution: mark running and process via cron immediate schedule to avoid timeout.
        $wpdb->update( $this->log_table, [ 'status' => 'running', 'started_at' => current_time( 'mysql' ) ], [ 'id' => $log_id ] );

        // Process in batches synchronously but safe. If file is huge, recommend WP-CLI or cron.
        $result = $this->process_file( $destination, $log_id, $batch_size );

        // update final status
        $status = $result['errors'] ? 'failed' : 'done';
        $wpdb->update( $this->log_table, [
            'status' => $status,
            'rows_total' => $result['rows_total'],
            'rows_processed' => $result['rows_processed'],
            'inserted' => $result['inserted'],
            'updated' => $result['updated'],
            'ignored' => $result['ignored'],
            'errors' => maybe_serialize( $result['errors'] ),
            'finished_at' => current_time( 'mysql' )
        ], [ 'id' => $log_id ] );

        // Redirect to history
        wp_redirect( admin_url( 'admin.php?page=ingredient_fiches_history' ) );
        exit;
    }

    public function preview_file( $path ) {
        // return first 10 rows parsed
        $rows = [];
        $reader = $this->get_reader( $path );
        if ( $reader['type'] === 'php' ) {
            try {
                $spreadsheet = $reader['reader']->load( $path );
                $worksheet = $spreadsheet->getActiveSheet();
                $i = 0;
                foreach ( $worksheet->getRowIterator() as $row ) {
                    if ( $i++ >= 10 ) break;
                    $cellIterator = $row->getCellIterator();
                    $cellIterator->setIterateOnlyExistingCells(false);
                    $rowData = [];
                    foreach ( $cellIterator as $cell ) {
                        $rowData[] = $cell->getValue();
                    }
                    $rows[] = $rowData;
                }
            } catch ( Exception $e ) {
                $rows[] = [ 'error' => $e->getMessage() ];
            }
        } else {
            // CSV fallback
            if ( ( $handle = fopen( $path, 'r' ) ) !== false ) {
                $i = 0;
                while ( ( $data = fgetcsv( $handle, 0, ',' ) ) !== false && $i++ < 10 ) {
                    $rows[] = $data;
                }
                fclose( $handle );
            }
        }
        return $rows;
    }

    protected function get_reader( $path ) {
        // Returns ['type' => 'php'|'csv', 'reader' => ReaderInstance]
        // If PhpSpreadsheet available, return reader. Otherwise csv fallback.
        if ( class_exists( '\PhpOffice\PhpSpreadsheet\Reader\Xlsx' ) ) {
            try {
                $ext = strtolower( pathinfo( $path, PATHINFO_EXTENSION ) );
                if ( $ext === 'csv' ) {
                    $reader = new \PhpOffice\PhpSpreadsheet\Reader\Csv();
                    $reader->setDelimiter(',');
                } elseif ( $ext === 'xls' ) {
                    $reader = new \PhpOffice\PhpSpreadsheet\Reader\Xls();
                } else {
                    $reader = new \PhpOffice\PhpSpreadsheet\Reader\Xlsx();
                }
                $reader->setReadDataOnly( true );
                return [ 'type' => 'php', 'reader' => $reader ];
            } catch ( Exception $e ) {
                return [ 'type' => 'csv', 'reader' => null ];
            }
        }
        return [ 'type' => 'csv', 'reader' => null ];
    }

    public function process_file( $path, $log_id = null, $batch_size = 500 ) {
        global $wpdb;
        $inserted = 0;
        $updated = 0;
        $ignored = 0;
        $rows_total = 0;
        $rows_processed = 0;
        $errors = [];

        $reader_meta = $this->get_reader( $path );
        if ( $reader_meta['type'] === 'php' ) {
            $reader = $reader_meta['reader'];
            try {
                $spreadsheet = $reader->load( $path );
                $worksheet = $spreadsheet->getActiveSheet();

                $header = [];
                $first = true;
                $batch = [];
                foreach ( $worksheet->getRowIterator() as $row_index => $row ) {
                    $cellIterator = $row->getCellIterator();
                    $cellIterator->setIterateOnlyExistingCells(false);
                    $rowData = [];
                    foreach ( $cellIterator as $cell ) {
                        $rowData[] = $cell->getValue();
                    }

                    // Detect header
                    if ( $first ) {
                        $header = $this->normalize_header( $rowData );
                        $first = false;
                        continue;
                    }

                    // Map row
                    $assoc = $this->map_row_by_header( $header, $rowData );
                    $rows_total++;
                    $batch[] = $assoc;

                    if ( count( $batch ) >= $batch_size ) {
                        $res = $this->process_batch( $batch );
                        $inserted += $res['inserted'];
                        $updated += $res['updated'];
                        $ignored += $res['ignored'];
                        $rows_processed += count( $batch );
                        $batch = [];
                        // update log
                        if ( $log_id ) {
                            $wpdb->update( $this->log_table, [ 'rows_processed' => $rows_processed, 'inserted' => $inserted, 'updated' => $updated, 'ignored' => $ignored ], [ 'id' => $log_id ] );
                        }
                    }
                }

                // remaining
                if ( count( $batch ) ) {
                    $res = $this->process_batch( $batch );
                    $inserted += $res['inserted'];
                    $updated += $res['updated'];
                    $ignored += $res['ignored'];
                    $rows_processed += count( $batch );
                }

            } catch ( Exception $e ) {
                $errors[] = $e->getMessage();
            }
        } else {
            // CSV fallback
            if ( ( $handle = fopen( $path, 'r' ) ) !== false ) {
                $header = [];
                $first = true;
                $batch = [];
                while ( ( $data = fgetcsv( $handle, 0, ',' ) ) !== false ) {
                    if ( $first ) {
                        $header = $this->normalize_header( $data );
                        $first = false;
                        continue;
                    }
                    $assoc = $this->map_row_by_header( $header, $data );
                    $rows_total++;
                    $batch[] = $assoc;
                    if ( count( $batch ) >= $batch_size ) {
                        $res = $this->process_batch( $batch );
                        $inserted += $res['inserted'];
                        $updated += $res['updated'];
                        $ignored += $res['ignored'];
                        $rows_processed += count( $batch );
                        $batch = [];
                        if ( $log_id ) {
                            $wpdb->update( $this->log_table, [ 'rows_processed' => $rows_processed, 'inserted' => $inserted, 'updated' => $updated, 'ignored' => $ignored ], [ 'id' => $log_id ] );
                        }
                    }
                }
                if ( count( $batch ) ) {
                    $res = $this->process_batch( $batch );
                    $inserted += $res['inserted'];
                    $updated += $res['updated'];
                    $ignored += $res['ignored'];
                    $rows_processed += count( $batch );
                }
                fclose( $handle );
            } else {
                $errors[] = 'Impossible d\'ouvrir le fichier CSV';
            }
        }

        return [
            'rows_total' => $rows_total,
            'rows_processed' => $rows_processed,
            'inserted' => $inserted,
            'updated' => $updated,
            'ignored' => $ignored,
            'errors' => $errors,
        ];
    }

    protected function normalize_header( $row ) {
        $normalized = [];
    
        foreach ( $row as $col ) {
            $h = trim($col);
            // clean invalid UTF-8
            $h = mb_convert_encoding($h, 'UTF-8', 'UTF-8');
            $h = strtolower($h);
    
            // remove accents safely
            $h = iconv('UTF-8', 'ASCII//TRANSLIT//IGNORE', $h);
    
            // replace spaces by underscores
            $h = str_replace(' ', '_', $h);
    
            // remove anything not valid for keys
            $h = preg_replace('/[^a-z0-9_]/', '', $h);
    
            // map canonical keys
            if ( in_array( $h, ['reference', 'ref', 'ref_', 'n_reference'], true ) ) $h = 'reference';
            if ( in_array( $h, ['intitule', 'intitule_', 'titre', 'libelle'], true ) ) $h = 'intitule';
            if ( in_array( $h, ['ingredients_francais','ingredient_francais','ingredients','ingredient','ingredients_français','liste_ingredients','composition'], true ) ) $h = 'ingredients_francais';
    
            $normalized[] = $h;
        }
    
        return $normalized;
    }
    

    protected function map_row_by_header( $header, $row ) {
        $assoc = [];
        foreach ( $header as $i => $h ) {
            $assoc[ $h ] = isset( $row[ $i ] ) ? $row[ $i ] : null;
        }
        return $assoc;
    }

    protected function process_batch( $batch ) {

        $inserted = 0;
        $updated = 0;
        $ignored = 0;

        foreach ( $batch as $row ) {
            // We expect keys normalized such as 'reference', 'intitule', 'ingredients_francais' based on sample
            $reference = isset( $row['reference'] ) ? trim( (string) $row['reference'] ) : '';
            $intitule = isset( $row['intitule'] ) ? trim( (string) $row['intitule'] ) : '';
            // Sometimes header may be 'ingredients_francais' or 'ingredients_francais' etc.
            $ingredients_key = null;
            foreach ( ['ingredients_francais', 'ingredients_francais', 'ingredients', 'ingredients_francais'] as $k ) {
                if ( isset( $row[ $k ] ) ) { $ingredients_key = $k; break; }
            }

            if ( ! $ingredients_key ) {
                // try to find a header that contains 'ingredient'
                foreach ( $row as $k => $v ) {
                    if ( strpos( $k, 'ingredient' ) !== false ) { $ingredients_key = $k; break; }
                }
            }
            $ingredients = $ingredients_key ? $row[ $ingredients_key ] : '';

            if ( empty( $reference ) ) {
                $ignored++;
                continue;
            }

            // sanitize
            $reference_s = sanitize_text_field( $reference );
            $title_s = sanitize_text_field( $intitule ?: $reference_s );
            // Ingredients can be long; allow some HTML but sanitize
            $ingredients_s = wp_kses_post( nl2br( trim( (string) $ingredients ) ) );

            // Try to find existing post by meta _ingredient_reference
            $existing = $this->get_post_by_reference( $reference_s );


            if ( $existing ) {
                // update
                $post_id = $existing;
                wp_update_post( [ 'ID' => $post_id, 'post_title' => $title_s, 'post_content' => $ingredients_s ] );
                update_post_meta( $post_id, '_ingredient_reference', $reference_s );
                update_post_meta( $post_id, '_ingredient_intitule', $title_s );
                update_post_meta( $post_id, '_ingredient_ingredients_fr', $ingredients_s );
                $updated++;
            } else {
                // insert
                $post_id = wp_insert_post( [
                    'post_type' => 'ingredient_fiche',
                    'post_title' => $title_s,
                    'post_content' => $ingredients_s,
                    'post_status' => 'publish'
                ] );
                if ( is_wp_error( $post_id ) || ! $post_id ) {
                    // Could not insert
                    $ignored++;
                    continue;
                }
                update_post_meta( $post_id, '_ingredient_reference', $reference_s );
                update_post_meta( $post_id, '_ingredient_intitule', $title_s );
                update_post_meta( $post_id, '_ingredient_ingredients_fr', $ingredients_s );
                $inserted++;
            }
        }
        return [ 'inserted' => $inserted, 'updated' => $updated, 'ignored' => $ignored ];
    }

    protected function get_post_by_reference( $reference ) {
        global $wpdb;
        $meta_key = '_ingredient_reference';
        $sql = $wpdb->prepare( "SELECT post_id FROM {$wpdb->postmeta} WHERE meta_key = %s AND meta_value = %s LIMIT 1", $meta_key, $reference );
        return $wpdb->get_var( $sql );
    }

    public function cron_process_pending_imports() {
        global $wpdb;
        $pending = $wpdb->get_row( "SELECT * FROM {$this->log_table} WHERE status = 'pending' ORDER BY id ASC LIMIT 1" );
        if ( ! $pending ) return;
        $wpdb->update( $this->log_table, [ 'status' => 'running', 'started_at' => current_time( 'mysql' ) ], [ 'id' => $pending->id ] );
        $res = $this->process_file( $pending->file_path, $pending->id, 500 );
        $status = $res['errors'] ? 'failed' : 'done';
        $wpdb->update( $this->log_table, [
            'status' => $status,
            'rows_total' => $res['rows_total'],
            'rows_processed' => $res['rows_processed'],
            'inserted' => $res['inserted'],
            'updated' => $res['updated'],
            'ignored' => $res['ignored'],
            'errors' => maybe_serialize( $res['errors'] ),
            'finished_at' => current_time( 'mysql' )
        ], [ 'id' => $pending->id ] );
    }

    public function register_rest_routes() {
        register_rest_route( 'ingr/v1', '/imports', [
            'methods' => 'GET',
            'callback' => [ $this, 'rest_get_imports' ],
            'permission_callback' => function() { return current_user_can( 'manage_options' ); }
        ] );
    }

    public function rest_get_imports( $request ) {
        global $wpdb;
        $rows = $wpdb->get_results( "SELECT * FROM {$this->log_table} ORDER BY id DESC LIMIT 100" );
        return rest_ensure_response( $rows );
    }

}

Ingredient_Importer::instance();

// -------------------------------
// CRON-ONLY import wrapper + scanner
// (remplace WP-CLI block — WP-CLI removed)
// -------------------------------

/**
 * Wrapper utilitaire global pour lancer un import sur un fichier donné.
 * - $file : chemin absolu vers le fichier
 * - $opts : tableau d'options (batch_size => int, save_logs => bool, move_processed => bool)
 *
 * Retourne le tableau résultat de process_file()
 */
if ( ! function_exists( 'ingredient_import_process_file' ) ) {
    function ingredient_import_process_file( $file, $opts = [] ) {
        global $wpdb;

        $opts = wp_parse_args( $opts, [
            'batch_size'     => 500,
            'save_logs'      => true,
            'move_processed' => true, // déplace dans processed/ après succès
        ] );

        $importer = Ingredient_Importer::instance();

        // create log record (pending -> running)
        if ( $opts['save_logs'] ) {
            $wpdb->insert(
                $importer->log_table,
                [
                    'file_name'      => basename( $file ),
                    'file_path'      => $file,
                    'rows_total'     => 0,
                    'rows_processed' => 0,
                    'inserted'       => 0,
                    'updated'        => 0,
                    'ignored'        => 0,
                    'errors'         => '',
                    'status'         => 'running',
                    'started_at'     => current_time( 'mysql' ),
                    'finished_at'    => null,
                    'user_id'        => null,
                ],
                [ '%s','%s','%d','%d','%d','%d','%d','%s','%s','%s','%d' ]
            );
            $log_id = $wpdb->insert_id;
        } else {
            $log_id = null;
        }

        // Call the internal processor
        $result = $importer->process_file( $file, $log_id, intval( $opts['batch_size'] ) );

        // Update log record if requested
        if ( $opts['save_logs'] && $log_id ) {
            $status = ! empty( $result['errors'] ) ? 'failed' : 'done';
            $wpdb->update(
                $importer->log_table,
                [
                    'status'         => $status,
                    'rows_total'     => $result['rows_total'],
                    'rows_processed' => $result['rows_processed'],
                    'inserted'       => $result['inserted'],
                    'updated'        => $result['updated'],
                    'ignored'        => $result['ignored'],
                    'errors'         => maybe_serialize( $result['errors'] ),
                    'finished_at'    => current_time( 'mysql' )
                ],
                [ 'id' => $log_id ],
                [ '%s','%d','%d','%d','%d','%d','%s','%s' ],
                [ '%d' ]
            );
        }

        // Move processed file to processed/ on success (or failed/ on failure)
        if ( $opts['move_processed'] ) {
            $upload = wp_upload_dir();
            $base   = trailingslashit( $upload['basedir'] ) . 'ingredient-imports/';
            $processed_dir = $base . ( empty( $result['errors'] ) ? 'processed' : 'failed' ) . '/';
            if ( ! file_exists( $processed_dir ) ) {
                wp_mkdir_p( $processed_dir );
            }
            $dest = $processed_dir . basename( $file );
            // Use rename if possible
            @rename( $file, $dest );
        }

        return $result;
    }
}

    /**
     * Cron scanner: trouve le plus ancien fichier dans upload/ingredient-imports
     * et lance ingredient_import_process_file() dessus.
     * Hooké sur 'ingredient_import_cron_event'.
     */
    add_action( 'ingredient_import_cron_event', function() {
        // Use importer instance to access settings
        $importer = Ingredient_Importer::instance();
        $upload   = wp_upload_dir();
        $import_dir = trailingslashit( $upload['basedir'] ) . $importer->upload_subdir . '/';

        if ( ! is_dir( $import_dir ) ) {
            return;
        }

        // find files (exclude subfolders processed/ failed/)
        $files = glob( $import_dir . '*.{csv,xls,xlsx}', GLOB_BRACE );
        if ( ! $files || count( $files ) === 0 ) {
            return;
        }

        // sort by modification time ascending (oldest first)
        usort( $files, function( $a, $b ) {
            return filemtime( $a ) - filemtime( $b );
        } );

        // Process the first file in queue
        $file = $files[0];

        // Prevent race conditions: mark a lightweight lock file
        $lockfile = $file . '.lock';
        if ( file_exists( $lockfile ) ) {
            // another process is likely processing it
            return;
        }
        // create lock
        @file_put_contents( $lockfile, get_current_user_id() . '|' . time() );

        // Process (save logs and move processed)
        ingredient_import_process_file( $file, [ 'batch_size' => 500, 'save_logs' => true, 'move_processed' => true ] );

        // remove lock (rename move_processed already moved file; ensure lock removed)
        if ( file_exists( $lockfile ) ) {
            @unlink( $lockfile );
        }
    } );

    /**
     * Ensure a 15-minute cron schedule exists and schedule the event if missing.
     * We hook on 'init' to avoid executing on WP-CLI runs or cron runner context unnecessarily.
     */
    add_action( 'init', function() {
        // add custom schedule
        add_filter( 'cron_schedules', function( $schedules ) {
            if ( ! isset( $schedules['quarterhourly'] ) ) {
                $schedules['quarterhourly'] = [
                    'interval' => 15 * 60,
                    'display'  => 'Every 15 Minutes'
                ];
            }
            return $schedules;
        } );

        if ( ! wp_next_scheduled( 'ingredient_import_cron_event' ) ) {
            // schedule first run in 60 seconds to avoid immediate race
            wp_schedule_event( time() + 60, 'quarterhourly', 'ingredient_import_cron_event' );
        }
    } );


// EOF
